
JUP is kind of like JAML. In JAML elements are queued up to be generated by calling a series of nested functions, in JUP structures are declared using arrays;

for instance: ["div", { "class": "foo" }, "some text", ["br"]]

The value add here is that you can use any arbitrary string to represent the element, rather than registering a template you can simply assign the array to a variable. If an object literal is provided as the second argument, it is directly mapped to attributes of the element. Also since all values in the JUP structure are strings, they can be stubbed out and replaced with data when they get called;

for instance: ["{{tag}}", { "class": "foo" }, "some {{value}}", ["br"]]

This allows structures be data driven, and alleviates the need to use special keys like "cls", you can just use "class". Works great for SSJS and CSJS.

JUP weighs in currently with most functionality done at about ~140 lines of code, it's really simple and it's MIT.

There are so many of <%=these_template_engines%> out there and so many that mix content and code it boggles the mind, there's a number of micro-templating and markup generation solutions out there, but few of them address Separation Of Concerns. Designers should never need to confront code, and markup strings look awful in JS. JUP attempts to take the simplest approach to mapping javascript and data to markup production. Here are some examples...

["div"] // Renders "<div></div>"

["div", { "class": "foo" }] // Renders "<div class='foo'></div>"

["div", { "class": "foo" }, "content"] // Renders "<div class='foo'>content</div>"

["div", { "class": "foo" }, ["div"], "content"] // Renders "<div class='foo'><div></div>content</div>"

["div", { "class": "foo" }, "content", ["div"]] // Renders "<div class='foo'>content<div></div></div>"

JUP also has the ability to combine markup generation with data (using a supplant/crockford-like syntax) for instance...

["div", { "class": "{{replaceme}}" }]
