
![Alt text](http://29.media.tumblr.com/tumblr_l2xo55ndbA1qbo0zio1_r1_400.png)


JUP  generates HTML/XML, elements are queued up to be generated by declaring nested arrays, for instance: 

    ["div", { "class": "foo" }, "some text", ["br"]]

The value add here is that you can use any arbitrary string to represent the element, rather than registering a template you can simply assign the array to a variable. If an object literal is provided as the second argument, it is directly mapped to attributes of the element. Also since all values in the JUP structure are strings, they can be stubbed out and replaced with data when they get called, for instance: 

    ["{{tag}}", { "class": "foo" }, "some {{value}}", ["br"]]

This allows structures be data driven, and alleviates the need to use special keys like "cls", you can just use "class". Works great for SSJS and CSJS.

JUP weighs in currently with most functionality done at about less than 200 lines of code, its really simple.

There are so many of '<%=these_template_engines%>' out there!! Theres a number of micro-templating and markup generation solutions out there, but very few address Separation Of Concerns. Designers should never need to confront script code, and markup strings look awful in JS. JUP attempts to take the simplest approach to mapping javascript and data to markup production. Here are some examples...

    ["div"] // Renders: <div></div>

    ["div", { "class": "foo" }] // Renders: <div class="foo"></div>

    ["div", { "class": "foo" }, "content"] // Renders: <div class="foo">content</div>

    ["div", { "class": "foo" }, ["div"], "content"] // Renders: <div class="foo"><div></div>content</div>

    ["div", { "class": "foo" }, "content", ["div"]] // Renders: <div class="foo">content<div></div></div>

JUP also has the ability to combine markup generation with data (using a supplant/crockford-like syntax) for instance...

    ["div", { "class": "{{replaceme}}" }]
